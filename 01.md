請依照下列三個步驟修改對應的檔案。這將解決 「邏輯鎖誤殺 (Logical Paradox False Positive)」 與 「急症誤判 (Emergency False Positive)」 的問題，並修正評分標準。

步驟 1：修改 backend/app/prompts/translator.py (核心邏輯修復)
這是最重要的修改。我們需要更新 「物理自洽性協定 (白名單)」 與 「急症定義」。

請將 PHYSICAL_CONSISTENCY_PROTOCOL 表格與 語意分級 區塊替換為以下內容：

# backend/app/prompts/translator.py

### 1. 語意分級與急症攔截 (Semantic Grading & Red Flag)
# ... (前略)
- **[RED 紅燈 - 顯性急症]**: 
  - 定義: 出現危及生命的徵兆。
  - 關鍵字: "昏迷", "大出血", "口眼歪斜", "胸痛徹背", "劇烈胸痛伴瀕死感", "腹痛如刀割(板狀腹)".
  - **例外豁免 (EXCEPTION)**: 若描述為 **"喉嚨/咽喉"** 的刀割樣痛，視為 **YELLOW** (風熱/扁桃腺)，**非** RED 急症。

# ... (中略)

### 4. PHYSICAL CONSISTENCY PROTOCOL (物理自洽性協定 - V4 Ultimate)

**互斥邏輯與豁免矩陣 (ME Matrix - V4)**:

| 維度 | 屬性 A (State A) | 屬性 B (State B) | ✅ 合理例外白名單 (Whitelist - DO NOT REJECT) |
| :--- | :--- | :--- | :--- |
| **寒熱** | 惡寒 / 肢冷 / 無熱 | 發熱 / 面赤 / 自覺熱 | **"身熱不揚"** (自覺熱但觸之不熱-濕溫); **"上熱下寒"** (寒熱錯雜); **"真寒假熱"**; **"寒熱往來"**; **"發熱惡寒"**; **"冷汗淋漓伴肢冷"** (亡陽); **"骨蒸潮熱"** |
| **虛實** | 無力 / 氣短 / 萎軟 | 有力 / 聲高 / 躁動 | **"動則汗出伴乏力"** (氣虛自汗); **"經量多而色淡"** (氣虛不攝); **"步態不穩伴脈有力"** (肝風內動); **"腹痛拒按但喜溫"** (寒實) |
| **分泌物** | 清稀 / 水樣 / 白 | 黏稠 / 黃濁 / 臭 | **"白痰而黏稠"** (痰濕/陰虛); **"大便色深無臭"** (陰寒凝滯/瘀血); **"迎風流淚伴黃痰"**; **"清涕伴黃痰"** (寒包火) |
| **脈象** | 浮 / 數 / 滑 / 緊 | 沉 / 遲 / 澀 / 微 | **"脈浮緊"**; **"脈沉數"**; **"脈浮緩"**; **"脈浮數"**; **"脈浮無力"**; **"脈沉細數"**; **"脈弦長有力"** (高血壓/肝陽) |
| **排汗** | 無汗 | 大汗 / 自汗 / 盜汗 | **"汗出而熱不退"** (濕熱/陽明); **"戰汗"**; **"頭汗出"**; **"半身出汗"**; **"絕汗/油汗"** |
| **疼痛** | 劇痛 / 固定 | 隱痛 / 遊走 | **"痛引肩背手臂"** (經絡痺阻); **"痛處喜按"**; **"痛無定處"** |
| **綜合** | 舌象屬熱(紅) | 脈象屬表(浮) | **"脈浮而舌紅"** (表裡同病/風熱); **"納呆嘔噁伴腹脹"** (痰濕中阻); **"舍舌從脈"**; **"舍脈從舌"** |

# ... (後略)

步驟 2：修改 backend/app/evaluation/scbr_evaluator.py (評分邏輯修復)
修正 Metric 10 的計算邏輯，使其符合 evaluation.md 定義（檢查 Risk Level 而非模糊項）。

請找到 calculate_funnel_adherence 函數並替換為：

# backend/app/evaluation/scbr_evaluator.py

    def calculate_funnel_adherence(self) -> float:
        """指標 10: Funnel Adherence Score (修正版 - 檢查 Risk Level)"""
        illegal = 0
        total = 0
        
        for log in self.logs:
            total += 1
            # 規則 1: 急症漏接 (GT是急症，但系統沒給出相應的反應)
            # 允許反應: EMERGENCY_ABORT (最理想), FALLBACK, INQUIRY_ONLY (至少沒亂確診)
            if log.get('is_emergency_gt'):
                if log['pred_response_type'] not in ['EMERGENCY_ABORT', 'FALLBACK', 'INQUIRY_ONLY']:
                     illegal += 1
            
            # 規則 2: 盲目確診 (Blind Confidence)
            # 定義: Translator 標記 risk 為 UNCERTAIN 或 RED，但系統卻給出 DEFINITIVE
            elif log.get('pred_risk_level') in ['UNCERTAIN', 'RED'] and log['pred_response_type'] == 'DEFINITIVE':
                illegal += 1
                
        return 1.0 - (illegal / total) if total > 0 else 1.0


步驟 3：修改 backend/app/evaluation/test_dataset.json (資料補強)
為了讓 Metric 1 (Hybrid Accuracy) 的排汗懲罰生效，請在所有類別的案例中補上 "sweat" 屬性。

修改範例 (請應用於類似案例)：

無汗類 (麻黃湯證/寒濕/表實) -> 加入 "sweat": "no_sweat"


有汗類 (桂枝湯證/濕熱/亡陽) -> 加入 "sweat": "sweat"


JSON 結構範例：

{
    "id": "CASE_A_Respiratory_004",
    "expected_diagnosis": "風寒感冒",
    "expected_attributes": {
      "nature": "cold",
      "deficiency": "excess",
      "sweat": "no_sweat"  // <--- 請補上這一行
    },
    // ...
  }

步驟 4：修改 backend/app/evaluation/scbr_evaluator.py (召回率升級)
目標：將 Metric 2 (Effective Recall) 從「字串比對」升級為 「語意向量比對」。 原因：系統輸出 風寒表證，標準答案是 風寒感冒。字串不同，但醫理相同。舊版會判錯，新版必須判對。

請找到 calculate_effective_recall 函數，並將其替換為以下支援 similarity_threshold 的版本：

def calculate_effective_recall(self, similarity_threshold: float = 0.85) -> float:
        """
        指標 2: Effective Recall (語意版 - 關鍵修正)
        過濾: 忽略 INQUIRY_ONLY
        判定: 字串相同 OR 向量相似度 > 0.85 即視為命中 (TP)
        """
        tp = 0
        denominator = 0
        
        for log in self.logs:
            if not log.get('gt_diagnosis'): continue
            
            # 忽略 INQUIRY (視為延遲決策)
            if log['pred_response_type'] == 'INQUIRY_ONLY':
                continue
            
            # 分母: 只要不是 Inquiry 都算 (包含 Definitive 和 Fallback/Rejected)
            denominator += 1
            
            # 分子: 必須是 DEFINITIVE 且 (字串相同 OR 語意相似)
            if log['pred_response_type'] == 'DEFINITIVE':
                is_match = False
                
                # 1. 字串比對 (Fast Path)
                if log['pred_diagnosis'] == log['gt_diagnosis']:
                    is_match = True
                
                # 2. 向量比對 (Semantic Path) - 這是救回分數的關鍵！
                elif log.get('pred_vector') and log.get('gt_vector'):
                    sim = self._get_cosine_sim(log['pred_vector'], log['gt_vector'])
                    if sim >= similarity_threshold:
                        is_match = True
                
                if is_match:
                    tp += 1
                
        return tp / denominator if denominator > 0 else 0.0